/**
* This file was automatically generated by @cosmwasm/ts-codegen@1.10.0.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { UseQueryOptions, useQuery, useMutation, UseMutationOptions } from "@tanstack/react-query";
import { ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { StdFee, Coin } from "@cosmjs/amino";
import { Decimal, Uint128, InstantiateMsg, ExecuteMsg, Binary, Cw721ReceiveMsg, QueryMsg, MigrateMsg, AllRoyaltyListResponse, AllRoyaltyResponse, AuctionType, AuctionResponse, AuctionListResponse, Addr, BidHistoryByAuctionIdResponse, Bid, CalculatePriceResponse, ConfigResponse, RoyaltyAdminResponse, RoyaltyFeeResponse, RoyaltyResponse, StateResponse } from "./JMarketplace.types";
import { JMarketplaceQueryClient, JMarketplaceClient } from "./JMarketplace.client";
export const jMarketplaceQueryKeys = {
  contract: ([{
    contract: "jMarketplace"
  }] as const),
  address: (contractAddress: string | undefined) => ([{
    ...jMarketplaceQueryKeys.contract[0],
    address: contractAddress
  }] as const),
  config: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...jMarketplaceQueryKeys.address(contractAddress)[0],
    method: "config",
    args
  }] as const),
  state: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...jMarketplaceQueryKeys.address(contractAddress)[0],
    method: "state",
    args
  }] as const),
  auction: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...jMarketplaceQueryKeys.address(contractAddress)[0],
    method: "auction",
    args
  }] as const),
  royaltyFee: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...jMarketplaceQueryKeys.address(contractAddress)[0],
    method: "royalty_fee",
    args
  }] as const),
  royaltyAdmin: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...jMarketplaceQueryKeys.address(contractAddress)[0],
    method: "royalty_admin",
    args
  }] as const),
  allRoyaltyFee: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...jMarketplaceQueryKeys.address(contractAddress)[0],
    method: "all_royalty_fee",
    args
  }] as const),
  calculatePrice: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...jMarketplaceQueryKeys.address(contractAddress)[0],
    method: "calculate_price",
    args
  }] as const),
  nftAuction: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...jMarketplaceQueryKeys.address(contractAddress)[0],
    method: "nft_auction",
    args
  }] as const),
  bidHistoryByAuctionId: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...jMarketplaceQueryKeys.address(contractAddress)[0],
    method: "bid_history_by_auction_id",
    args
  }] as const),
  bidsCount: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...jMarketplaceQueryKeys.address(contractAddress)[0],
    method: "bids_count",
    args
  }] as const),
  auctionByContract: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...jMarketplaceQueryKeys.address(contractAddress)[0],
    method: "auction_by_contract",
    args
  }] as const),
  auctionBySeller: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...jMarketplaceQueryKeys.address(contractAddress)[0],
    method: "auction_by_seller",
    args
  }] as const),
  auctionByAmount: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...jMarketplaceQueryKeys.address(contractAddress)[0],
    method: "auction_by_amount",
    args
  }] as const),
  auctionByEndTime: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...jMarketplaceQueryKeys.address(contractAddress)[0],
    method: "auction_by_end_time",
    args
  }] as const),
  notStartedAuction: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...jMarketplaceQueryKeys.address(contractAddress)[0],
    method: "not_started_auction",
    args
  }] as const),
  auctionByBidder: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...jMarketplaceQueryKeys.address(contractAddress)[0],
    method: "auction_by_bidder",
    args
  }] as const)
};
export const jMarketplaceQueries = {
  config: <TData = ConfigResponse,>({
    client,
    options
  }: JMarketplaceConfigQuery<TData>): UseQueryOptions<ConfigResponse, Error, TData> => ({
    queryKey: jMarketplaceQueryKeys.config(client?.contractAddress),
    queryFn: () => client ? client.config() : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  state: <TData = StateResponse,>({
    client,
    options
  }: JMarketplaceStateQuery<TData>): UseQueryOptions<StateResponse, Error, TData> => ({
    queryKey: jMarketplaceQueryKeys.state(client?.contractAddress),
    queryFn: () => client ? client.state() : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  auction: <TData = AuctionResponse,>({
    client,
    args,
    options
  }: JMarketplaceAuctionQuery<TData>): UseQueryOptions<AuctionResponse, Error, TData> => ({
    queryKey: jMarketplaceQueryKeys.auction(client?.contractAddress, args),
    queryFn: () => client ? client.auction({
      auctionId: args.auctionId
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  royaltyFee: <TData = RoyaltyFeeResponse,>({
    client,
    args,
    options
  }: JMarketplaceRoyaltyFeeQuery<TData>): UseQueryOptions<RoyaltyFeeResponse, Error, TData> => ({
    queryKey: jMarketplaceQueryKeys.royaltyFee(client?.contractAddress, args),
    queryFn: () => client ? client.royaltyFee({
      contractAddr: args.contractAddr
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  royaltyAdmin: <TData = RoyaltyAdminResponse,>({
    client,
    args,
    options
  }: JMarketplaceRoyaltyAdminQuery<TData>): UseQueryOptions<RoyaltyAdminResponse, Error, TData> => ({
    queryKey: jMarketplaceQueryKeys.royaltyAdmin(client?.contractAddress, args),
    queryFn: () => client ? client.royaltyAdmin({
      address: args.address
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  allRoyaltyFee: <TData = AllRoyaltyListResponse,>({
    client,
    args,
    options
  }: JMarketplaceAllRoyaltyFeeQuery<TData>): UseQueryOptions<AllRoyaltyListResponse, Error, TData> => ({
    queryKey: jMarketplaceQueryKeys.allRoyaltyFee(client?.contractAddress, args),
    queryFn: () => client ? client.allRoyaltyFee({
      limit: args.limit,
      startAfter: args.startAfter
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  calculatePrice: <TData = CalculatePriceResponse,>({
    client,
    args,
    options
  }: JMarketplaceCalculatePriceQuery<TData>): UseQueryOptions<CalculatePriceResponse, Error, TData> => ({
    queryKey: jMarketplaceQueryKeys.calculatePrice(client?.contractAddress, args),
    queryFn: () => client ? client.calculatePrice({
      amount: args.amount,
      nftContract: args.nftContract,
      tokenId: args.tokenId
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  nftAuction: <TData = AuctionResponse,>({
    client,
    args,
    options
  }: JMarketplaceNftAuctionQuery<TData>): UseQueryOptions<AuctionResponse, Error, TData> => ({
    queryKey: jMarketplaceQueryKeys.nftAuction(client?.contractAddress, args),
    queryFn: () => client ? client.nftAuction({
      nftContract: args.nftContract,
      tokenId: args.tokenId
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  bidHistoryByAuctionId: <TData = BidHistoryByAuctionIdResponse,>({
    client,
    args,
    options
  }: JMarketplaceBidHistoryByAuctionIdQuery<TData>): UseQueryOptions<BidHistoryByAuctionIdResponse, Error, TData> => ({
    queryKey: jMarketplaceQueryKeys.bidHistoryByAuctionId(client?.contractAddress, args),
    queryFn: () => client ? client.bidHistoryByAuctionId({
      auctionId: args.auctionId,
      limit: args.limit
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  bidsCount: <TData = AuctionResponse,>({
    client,
    args,
    options
  }: JMarketplaceBidsCountQuery<TData>): UseQueryOptions<AuctionResponse, Error, TData> => ({
    queryKey: jMarketplaceQueryKeys.bidsCount(client?.contractAddress, args),
    queryFn: () => client ? client.bidsCount({
      auctionId: args.auctionId
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  auctionByContract: <TData = AuctionListResponse,>({
    client,
    args,
    options
  }: JMarketplaceAuctionByContractQuery<TData>): UseQueryOptions<AuctionListResponse, Error, TData> => ({
    queryKey: jMarketplaceQueryKeys.auctionByContract(client?.contractAddress, args),
    queryFn: () => client ? client.auctionByContract({
      limit: args.limit,
      nftContract: args.nftContract
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  auctionBySeller: <TData = AuctionListResponse,>({
    client,
    args,
    options
  }: JMarketplaceAuctionBySellerQuery<TData>): UseQueryOptions<AuctionListResponse, Error, TData> => ({
    queryKey: jMarketplaceQueryKeys.auctionBySeller(client?.contractAddress, args),
    queryFn: () => client ? client.auctionBySeller({
      limit: args.limit,
      seller: args.seller
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  auctionByAmount: <TData = AuctionListResponse,>({
    client,
    args,
    options
  }: JMarketplaceAuctionByAmountQuery<TData>): UseQueryOptions<AuctionListResponse, Error, TData> => ({
    queryKey: jMarketplaceQueryKeys.auctionByAmount(client?.contractAddress, args),
    queryFn: () => client ? client.auctionByAmount({
      amount: args.amount,
      limit: args.limit,
      nftContract: args.nftContract
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  auctionByEndTime: <TData = AuctionListResponse,>({
    client,
    args,
    options
  }: JMarketplaceAuctionByEndTimeQuery<TData>): UseQueryOptions<AuctionListResponse, Error, TData> => ({
    queryKey: jMarketplaceQueryKeys.auctionByEndTime(client?.contractAddress, args),
    queryFn: () => client ? client.auctionByEndTime({
      endTime: args.endTime,
      isDesc: args.isDesc,
      limit: args.limit,
      nftContract: args.nftContract
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  notStartedAuction: <TData = AuctionListResponse,>({
    client,
    args,
    options
  }: JMarketplaceNotStartedAuctionQuery<TData>): UseQueryOptions<AuctionListResponse, Error, TData> => ({
    queryKey: jMarketplaceQueryKeys.notStartedAuction(client?.contractAddress, args),
    queryFn: () => client ? client.notStartedAuction({
      isDesc: args.isDesc,
      limit: args.limit,
      nftContract: args.nftContract,
      startAfter: args.startAfter
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  auctionByBidder: <TData = AuctionListResponse,>({
    client,
    args,
    options
  }: JMarketplaceAuctionByBidderQuery<TData>): UseQueryOptions<AuctionListResponse, Error, TData> => ({
    queryKey: jMarketplaceQueryKeys.auctionByBidder(client?.contractAddress, args),
    queryFn: () => client ? client.auctionByBidder({
      bidder: args.bidder,
      limit: args.limit,
      startAfter: args.startAfter
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  })
};
export interface JMarketplaceReactQuery<TResponse, TData = TResponse> {
  client: JMarketplaceQueryClient | undefined;
  options?: Omit<UseQueryOptions<TResponse, Error, TData>, "'queryKey' | 'queryFn' | 'initialData'"> & {
    initialData?: undefined;
  };
}
export interface JMarketplaceAuctionByBidderQuery<TData> extends JMarketplaceReactQuery<AuctionListResponse, TData> {
  args: {
    bidder: string;
    limit?: number;
    startAfter?: number;
  };
}
export function useJMarketplaceAuctionByBidderQuery<TData = AuctionListResponse>({
  client,
  args,
  options
}: JMarketplaceAuctionByBidderQuery<TData>) {
  return useQuery<AuctionListResponse, Error, TData>(jMarketplaceQueryKeys.auctionByBidder(client?.contractAddress, args), () => client ? client.auctionByBidder({
    bidder: args.bidder,
    limit: args.limit,
    startAfter: args.startAfter
  }) : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface JMarketplaceNotStartedAuctionQuery<TData> extends JMarketplaceReactQuery<AuctionListResponse, TData> {
  args: {
    isDesc?: boolean;
    limit?: number;
    nftContract: string;
    startAfter?: number;
  };
}
export function useJMarketplaceNotStartedAuctionQuery<TData = AuctionListResponse>({
  client,
  args,
  options
}: JMarketplaceNotStartedAuctionQuery<TData>) {
  return useQuery<AuctionListResponse, Error, TData>(jMarketplaceQueryKeys.notStartedAuction(client?.contractAddress, args), () => client ? client.notStartedAuction({
    isDesc: args.isDesc,
    limit: args.limit,
    nftContract: args.nftContract,
    startAfter: args.startAfter
  }) : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface JMarketplaceAuctionByEndTimeQuery<TData> extends JMarketplaceReactQuery<AuctionListResponse, TData> {
  args: {
    endTime: number;
    isDesc?: boolean;
    limit?: number;
    nftContract: string;
  };
}
export function useJMarketplaceAuctionByEndTimeQuery<TData = AuctionListResponse>({
  client,
  args,
  options
}: JMarketplaceAuctionByEndTimeQuery<TData>) {
  return useQuery<AuctionListResponse, Error, TData>(jMarketplaceQueryKeys.auctionByEndTime(client?.contractAddress, args), () => client ? client.auctionByEndTime({
    endTime: args.endTime,
    isDesc: args.isDesc,
    limit: args.limit,
    nftContract: args.nftContract
  }) : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface JMarketplaceAuctionByAmountQuery<TData> extends JMarketplaceReactQuery<AuctionListResponse, TData> {
  args: {
    amount: Uint128;
    limit?: number;
    nftContract: string;
  };
}
export function useJMarketplaceAuctionByAmountQuery<TData = AuctionListResponse>({
  client,
  args,
  options
}: JMarketplaceAuctionByAmountQuery<TData>) {
  return useQuery<AuctionListResponse, Error, TData>(jMarketplaceQueryKeys.auctionByAmount(client?.contractAddress, args), () => client ? client.auctionByAmount({
    amount: args.amount,
    limit: args.limit,
    nftContract: args.nftContract
  }) : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface JMarketplaceAuctionBySellerQuery<TData> extends JMarketplaceReactQuery<AuctionListResponse, TData> {
  args: {
    limit?: number;
    seller: string;
  };
}
export function useJMarketplaceAuctionBySellerQuery<TData = AuctionListResponse>({
  client,
  args,
  options
}: JMarketplaceAuctionBySellerQuery<TData>) {
  return useQuery<AuctionListResponse, Error, TData>(jMarketplaceQueryKeys.auctionBySeller(client?.contractAddress, args), () => client ? client.auctionBySeller({
    limit: args.limit,
    seller: args.seller
  }) : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface JMarketplaceAuctionByContractQuery<TData> extends JMarketplaceReactQuery<AuctionListResponse, TData> {
  args: {
    limit?: number;
    nftContract: string;
  };
}
export function useJMarketplaceAuctionByContractQuery<TData = AuctionListResponse>({
  client,
  args,
  options
}: JMarketplaceAuctionByContractQuery<TData>) {
  return useQuery<AuctionListResponse, Error, TData>(jMarketplaceQueryKeys.auctionByContract(client?.contractAddress, args), () => client ? client.auctionByContract({
    limit: args.limit,
    nftContract: args.nftContract
  }) : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface JMarketplaceBidsCountQuery<TData> extends JMarketplaceReactQuery<AuctionResponse, TData> {
  args: {
    auctionId: Uint128;
  };
}
export function useJMarketplaceBidsCountQuery<TData = AuctionResponse>({
  client,
  args,
  options
}: JMarketplaceBidsCountQuery<TData>) {
  return useQuery<AuctionResponse, Error, TData>(jMarketplaceQueryKeys.bidsCount(client?.contractAddress, args), () => client ? client.bidsCount({
    auctionId: args.auctionId
  }) : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface JMarketplaceBidHistoryByAuctionIdQuery<TData> extends JMarketplaceReactQuery<BidHistoryByAuctionIdResponse, TData> {
  args: {
    auctionId: Uint128;
    limit?: number;
  };
}
export function useJMarketplaceBidHistoryByAuctionIdQuery<TData = BidHistoryByAuctionIdResponse>({
  client,
  args,
  options
}: JMarketplaceBidHistoryByAuctionIdQuery<TData>) {
  return useQuery<BidHistoryByAuctionIdResponse, Error, TData>(jMarketplaceQueryKeys.bidHistoryByAuctionId(client?.contractAddress, args), () => client ? client.bidHistoryByAuctionId({
    auctionId: args.auctionId,
    limit: args.limit
  }) : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface JMarketplaceNftAuctionQuery<TData> extends JMarketplaceReactQuery<AuctionResponse, TData> {
  args: {
    nftContract: string;
    tokenId: string;
  };
}
export function useJMarketplaceNftAuctionQuery<TData = AuctionResponse>({
  client,
  args,
  options
}: JMarketplaceNftAuctionQuery<TData>) {
  return useQuery<AuctionResponse, Error, TData>(jMarketplaceQueryKeys.nftAuction(client?.contractAddress, args), () => client ? client.nftAuction({
    nftContract: args.nftContract,
    tokenId: args.tokenId
  }) : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface JMarketplaceCalculatePriceQuery<TData> extends JMarketplaceReactQuery<CalculatePriceResponse, TData> {
  args: {
    amount: Uint128;
    nftContract: string;
    tokenId: string;
  };
}
export function useJMarketplaceCalculatePriceQuery<TData = CalculatePriceResponse>({
  client,
  args,
  options
}: JMarketplaceCalculatePriceQuery<TData>) {
  return useQuery<CalculatePriceResponse, Error, TData>(jMarketplaceQueryKeys.calculatePrice(client?.contractAddress, args), () => client ? client.calculatePrice({
    amount: args.amount,
    nftContract: args.nftContract,
    tokenId: args.tokenId
  }) : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface JMarketplaceAllRoyaltyFeeQuery<TData> extends JMarketplaceReactQuery<AllRoyaltyListResponse, TData> {
  args: {
    limit?: number;
    startAfter?: string;
  };
}
export function useJMarketplaceAllRoyaltyFeeQuery<TData = AllRoyaltyListResponse>({
  client,
  args,
  options
}: JMarketplaceAllRoyaltyFeeQuery<TData>) {
  return useQuery<AllRoyaltyListResponse, Error, TData>(jMarketplaceQueryKeys.allRoyaltyFee(client?.contractAddress, args), () => client ? client.allRoyaltyFee({
    limit: args.limit,
    startAfter: args.startAfter
  }) : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface JMarketplaceRoyaltyAdminQuery<TData> extends JMarketplaceReactQuery<RoyaltyAdminResponse, TData> {
  args: {
    address: string;
  };
}
export function useJMarketplaceRoyaltyAdminQuery<TData = RoyaltyAdminResponse>({
  client,
  args,
  options
}: JMarketplaceRoyaltyAdminQuery<TData>) {
  return useQuery<RoyaltyAdminResponse, Error, TData>(jMarketplaceQueryKeys.royaltyAdmin(client?.contractAddress, args), () => client ? client.royaltyAdmin({
    address: args.address
  }) : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface JMarketplaceRoyaltyFeeQuery<TData> extends JMarketplaceReactQuery<RoyaltyFeeResponse, TData> {
  args: {
    contractAddr: string;
  };
}
export function useJMarketplaceRoyaltyFeeQuery<TData = RoyaltyFeeResponse>({
  client,
  args,
  options
}: JMarketplaceRoyaltyFeeQuery<TData>) {
  return useQuery<RoyaltyFeeResponse, Error, TData>(jMarketplaceQueryKeys.royaltyFee(client?.contractAddress, args), () => client ? client.royaltyFee({
    contractAddr: args.contractAddr
  }) : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface JMarketplaceAuctionQuery<TData> extends JMarketplaceReactQuery<AuctionResponse, TData> {
  args: {
    auctionId: Uint128;
  };
}
export function useJMarketplaceAuctionQuery<TData = AuctionResponse>({
  client,
  args,
  options
}: JMarketplaceAuctionQuery<TData>) {
  return useQuery<AuctionResponse, Error, TData>(jMarketplaceQueryKeys.auction(client?.contractAddress, args), () => client ? client.auction({
    auctionId: args.auctionId
  }) : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface JMarketplaceStateQuery<TData> extends JMarketplaceReactQuery<StateResponse, TData> {}
export function useJMarketplaceStateQuery<TData = StateResponse>({
  client,
  options
}: JMarketplaceStateQuery<TData>) {
  return useQuery<StateResponse, Error, TData>(jMarketplaceQueryKeys.state(client?.contractAddress), () => client ? client.state() : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface JMarketplaceConfigQuery<TData> extends JMarketplaceReactQuery<ConfigResponse, TData> {}
export function useJMarketplaceConfigQuery<TData = ConfigResponse>({
  client,
  options
}: JMarketplaceConfigQuery<TData>) {
  return useQuery<ConfigResponse, Error, TData>(jMarketplaceQueryKeys.config(client?.contractAddress), () => client ? client.config() : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface JMarketplaceSettleHookMutation {
  client: JMarketplaceClient;
  msg: {
    nftContract: string;
    owner: string;
    tokenId: string;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useJMarketplaceSettleHookMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, JMarketplaceSettleHookMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, JMarketplaceSettleHookMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.settleHook(msg, fee, memo, funds), options);
}
export interface JMarketplaceAdminResumeMutation {
  client: JMarketplaceClient;
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useJMarketplaceAdminResumeMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, JMarketplaceAdminResumeMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, JMarketplaceAdminResumeMutation>(({
    client,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.adminResume(fee, memo, funds), options);
}
export interface JMarketplaceAdminPauseMutation {
  client: JMarketplaceClient;
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useJMarketplaceAdminPauseMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, JMarketplaceAdminPauseMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, JMarketplaceAdminPauseMutation>(({
    client,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.adminPause(fee, memo, funds), options);
}
export interface JMarketplaceSetRoyaltyAdminMutation {
  client: JMarketplaceClient;
  msg: {
    address: string;
    enable: boolean;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useJMarketplaceSetRoyaltyAdminMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, JMarketplaceSetRoyaltyAdminMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, JMarketplaceSetRoyaltyAdminMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.setRoyaltyAdmin(msg, fee, memo, funds), options);
}
export interface JMarketplaceSetRoyaltyFeeMutation {
  client: JMarketplaceClient;
  msg: {
    contractAddr: string;
    creator: string;
    royaltyFee: Decimal;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useJMarketplaceSetRoyaltyFeeMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, JMarketplaceSetRoyaltyFeeMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, JMarketplaceSetRoyaltyFeeMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.setRoyaltyFee(msg, fee, memo, funds), options);
}
export interface JMarketplaceAdminCancelAuctionMutation {
  client: JMarketplaceClient;
  msg: {
    auctionId: Uint128;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useJMarketplaceAdminCancelAuctionMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, JMarketplaceAdminCancelAuctionMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, JMarketplaceAdminCancelAuctionMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.adminCancelAuction(msg, fee, memo, funds), options);
}
export interface JMarketplaceAdminChangeConfigMutation {
  client: JMarketplaceClient;
  msg: {
    acceptedDenom: string[];
    collectorAddress: string;
    duration: number;
    extensionDuration: number;
    maxRoyaltyFee: Decimal;
    minIncrement: Decimal;
    minReservePrice: Uint128;
    protocolFee: Decimal;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useJMarketplaceAdminChangeConfigMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, JMarketplaceAdminChangeConfigMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, JMarketplaceAdminChangeConfigMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.adminChangeConfig(msg, fee, memo, funds), options);
}
export interface JMarketplaceSettleMutation {
  client: JMarketplaceClient;
  msg: {
    auctionId: Uint128;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useJMarketplaceSettleMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, JMarketplaceSettleMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, JMarketplaceSettleMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.settle(msg, fee, memo, funds), options);
}
export interface JMarketplacePlaceBidMutation {
  client: JMarketplaceClient;
  msg: {
    auctionId: Uint128;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useJMarketplacePlaceBidMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, JMarketplacePlaceBidMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, JMarketplacePlaceBidMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.placeBid(msg, fee, memo, funds), options);
}
export interface JMarketplaceCancelAuctionMutation {
  client: JMarketplaceClient;
  msg: {
    auctionId: Uint128;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useJMarketplaceCancelAuctionMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, JMarketplaceCancelAuctionMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, JMarketplaceCancelAuctionMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.cancelAuction(msg, fee, memo, funds), options);
}
export interface JMarketplaceReceiveNftMutation {
  client: JMarketplaceClient;
  msg: {
    msg: Binary;
    sender: string;
    tokenId: string;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useJMarketplaceReceiveNftMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, JMarketplaceReceiveNftMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, JMarketplaceReceiveNftMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.receiveNft(msg, fee, memo, funds), options);
}
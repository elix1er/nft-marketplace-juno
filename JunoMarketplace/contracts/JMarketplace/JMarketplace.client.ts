/**
* This file was automatically generated by @cosmwasm/ts-codegen@1.10.0.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { Coin, StdFee } from "@cosmjs/amino";
import { Decimal, Uint128, InstantiateMsg, ExecuteMsg, Binary, Cw721ReceiveMsg, QueryMsg, MigrateMsg, AllRoyaltyListResponse, AllRoyaltyResponse, AuctionType, AuctionResponse, AuctionListResponse, Addr, BidHistoryByAuctionIdResponse, Bid, CalculatePriceResponse, ConfigResponse, RoyaltyAdminResponse, RoyaltyFeeResponse, RoyaltyResponse, StateResponse } from "./JMarketplace.types";
export interface JMarketplaceReadOnlyInterface {
  contractAddress: string;
  config: () => Promise<ConfigResponse>;
  state: () => Promise<StateResponse>;
  auction: ({
    auctionId
  }: {
    auctionId: Uint128;
  }) => Promise<AuctionResponse>;
  royaltyFee: ({
    contractAddr
  }: {
    contractAddr: string;
  }) => Promise<RoyaltyFeeResponse>;
  royaltyAdmin: ({
    address
  }: {
    address: string;
  }) => Promise<RoyaltyAdminResponse>;
  allRoyaltyFee: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: string;
  }) => Promise<AllRoyaltyListResponse>;
  calculatePrice: ({
    amount,
    nftContract,
    tokenId
  }: {
    amount: Uint128;
    nftContract: string;
    tokenId: string;
  }) => Promise<CalculatePriceResponse>;
  nftAuction: ({
    nftContract,
    tokenId
  }: {
    nftContract: string;
    tokenId: string;
  }) => Promise<AuctionResponse>;
  bidHistoryByAuctionId: ({
    auctionId,
    limit
  }: {
    auctionId: Uint128;
    limit?: number;
  }) => Promise<BidHistoryByAuctionIdResponse>;
  bidsCount: ({
    auctionId
  }: {
    auctionId: Uint128;
  }) => Promise<AuctionResponse>;
  auctionByContract: ({
    limit,
    nftContract
  }: {
    limit?: number;
    nftContract: string;
  }) => Promise<AuctionListResponse>;
  auctionBySeller: ({
    limit,
    seller
  }: {
    limit?: number;
    seller: string;
  }) => Promise<AuctionListResponse>;
  auctionByAmount: ({
    amount,
    limit,
    nftContract
  }: {
    amount: Uint128;
    limit?: number;
    nftContract: string;
  }) => Promise<AuctionListResponse>;
  auctionByEndTime: ({
    endTime,
    isDesc,
    limit,
    nftContract
  }: {
    endTime: number;
    isDesc?: boolean;
    limit?: number;
    nftContract: string;
  }) => Promise<AuctionListResponse>;
  notStartedAuction: ({
    isDesc,
    limit,
    nftContract,
    startAfter
  }: {
    isDesc?: boolean;
    limit?: number;
    nftContract: string;
    startAfter?: number;
  }) => Promise<AuctionListResponse>;
  auctionByBidder: ({
    bidder,
    limit,
    startAfter
  }: {
    bidder: string;
    limit?: number;
    startAfter?: number;
  }) => Promise<AuctionListResponse>;
}
export class JMarketplaceQueryClient implements JMarketplaceReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;
  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.config = this.config.bind(this);
    this.state = this.state.bind(this);
    this.auction = this.auction.bind(this);
    this.royaltyFee = this.royaltyFee.bind(this);
    this.royaltyAdmin = this.royaltyAdmin.bind(this);
    this.allRoyaltyFee = this.allRoyaltyFee.bind(this);
    this.calculatePrice = this.calculatePrice.bind(this);
    this.nftAuction = this.nftAuction.bind(this);
    this.bidHistoryByAuctionId = this.bidHistoryByAuctionId.bind(this);
    this.bidsCount = this.bidsCount.bind(this);
    this.auctionByContract = this.auctionByContract.bind(this);
    this.auctionBySeller = this.auctionBySeller.bind(this);
    this.auctionByAmount = this.auctionByAmount.bind(this);
    this.auctionByEndTime = this.auctionByEndTime.bind(this);
    this.notStartedAuction = this.notStartedAuction.bind(this);
    this.auctionByBidder = this.auctionByBidder.bind(this);
  }
  config = async (): Promise<ConfigResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      config: {}
    });
  };
  state = async (): Promise<StateResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      state: {}
    });
  };
  auction = async ({
    auctionId
  }: {
    auctionId: Uint128;
  }): Promise<AuctionResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      auction: {
        auction_id: auctionId
      }
    });
  };
  royaltyFee = async ({
    contractAddr
  }: {
    contractAddr: string;
  }): Promise<RoyaltyFeeResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      royalty_fee: {
        contract_addr: contractAddr
      }
    });
  };
  royaltyAdmin = async ({
    address
  }: {
    address: string;
  }): Promise<RoyaltyAdminResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      royalty_admin: {
        address
      }
    });
  };
  allRoyaltyFee = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: string;
  }): Promise<AllRoyaltyListResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      all_royalty_fee: {
        limit,
        start_after: startAfter
      }
    });
  };
  calculatePrice = async ({
    amount,
    nftContract,
    tokenId
  }: {
    amount: Uint128;
    nftContract: string;
    tokenId: string;
  }): Promise<CalculatePriceResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      calculate_price: {
        amount,
        nft_contract: nftContract,
        token_id: tokenId
      }
    });
  };
  nftAuction = async ({
    nftContract,
    tokenId
  }: {
    nftContract: string;
    tokenId: string;
  }): Promise<AuctionResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      nft_auction: {
        nft_contract: nftContract,
        token_id: tokenId
      }
    });
  };
  bidHistoryByAuctionId = async ({
    auctionId,
    limit
  }: {
    auctionId: Uint128;
    limit?: number;
  }): Promise<BidHistoryByAuctionIdResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      bid_history_by_auction_id: {
        auction_id: auctionId,
        limit
      }
    });
  };
  bidsCount = async ({
    auctionId
  }: {
    auctionId: Uint128;
  }): Promise<AuctionResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      bids_count: {
        auction_id: auctionId
      }
    });
  };
  auctionByContract = async ({
    limit,
    nftContract
  }: {
    limit?: number;
    nftContract: string;
  }): Promise<AuctionListResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      auction_by_contract: {
        limit,
        nft_contract: nftContract
      }
    });
  };
  auctionBySeller = async ({
    limit,
    seller
  }: {
    limit?: number;
    seller: string;
  }): Promise<AuctionListResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      auction_by_seller: {
        limit,
        seller
      }
    });
  };
  auctionByAmount = async ({
    amount,
    limit,
    nftContract
  }: {
    amount: Uint128;
    limit?: number;
    nftContract: string;
  }): Promise<AuctionListResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      auction_by_amount: {
        amount,
        limit,
        nft_contract: nftContract
      }
    });
  };
  auctionByEndTime = async ({
    endTime,
    isDesc,
    limit,
    nftContract
  }: {
    endTime: number;
    isDesc?: boolean;
    limit?: number;
    nftContract: string;
  }): Promise<AuctionListResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      auction_by_end_time: {
        end_time: endTime,
        is_desc: isDesc,
        limit,
        nft_contract: nftContract
      }
    });
  };
  notStartedAuction = async ({
    isDesc,
    limit,
    nftContract,
    startAfter
  }: {
    isDesc?: boolean;
    limit?: number;
    nftContract: string;
    startAfter?: number;
  }): Promise<AuctionListResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      not_started_auction: {
        is_desc: isDesc,
        limit,
        nft_contract: nftContract,
        start_after: startAfter
      }
    });
  };
  auctionByBidder = async ({
    bidder,
    limit,
    startAfter
  }: {
    bidder: string;
    limit?: number;
    startAfter?: number;
  }): Promise<AuctionListResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      auction_by_bidder: {
        bidder,
        limit,
        start_after: startAfter
      }
    });
  };
}
export interface JMarketplaceInterface extends JMarketplaceReadOnlyInterface {
  contractAddress: string;
  sender: string;
  receiveNft: ({
    msg,
    sender,
    tokenId
  }: {
    msg: Binary;
    sender: string;
    tokenId: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  cancelAuction: ({
    auctionId
  }: {
    auctionId: Uint128;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  placeBid: ({
    auctionId
  }: {
    auctionId: Uint128;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  settle: ({
    auctionId
  }: {
    auctionId: Uint128;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  adminChangeConfig: ({
    acceptedDenom,
    collectorAddress,
    duration,
    extensionDuration,
    maxRoyaltyFee,
    minIncrement,
    minReservePrice,
    protocolFee
  }: {
    acceptedDenom: string[];
    collectorAddress: string;
    duration: number;
    extensionDuration: number;
    maxRoyaltyFee: Decimal;
    minIncrement: Decimal;
    minReservePrice: Uint128;
    protocolFee: Decimal;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  adminCancelAuction: ({
    auctionId
  }: {
    auctionId: Uint128;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  setRoyaltyFee: ({
    contractAddr,
    creator,
    royaltyFee
  }: {
    contractAddr: string;
    creator: string;
    royaltyFee: Decimal;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  setRoyaltyAdmin: ({
    address,
    enable
  }: {
    address: string;
    enable: boolean;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  adminPause: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  adminResume: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  settleHook: ({
    nftContract,
    owner,
    tokenId
  }: {
    nftContract: string;
    owner: string;
    tokenId: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
}
export class JMarketplaceClient extends JMarketplaceQueryClient implements JMarketplaceInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;
  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.receiveNft = this.receiveNft.bind(this);
    this.cancelAuction = this.cancelAuction.bind(this);
    this.placeBid = this.placeBid.bind(this);
    this.settle = this.settle.bind(this);
    this.adminChangeConfig = this.adminChangeConfig.bind(this);
    this.adminCancelAuction = this.adminCancelAuction.bind(this);
    this.setRoyaltyFee = this.setRoyaltyFee.bind(this);
    this.setRoyaltyAdmin = this.setRoyaltyAdmin.bind(this);
    this.adminPause = this.adminPause.bind(this);
    this.adminResume = this.adminResume.bind(this);
    this.settleHook = this.settleHook.bind(this);
  }
  receiveNft = async ({
    msg,
    sender,
    tokenId
  }: {
    msg: Binary;
    sender: string;
    tokenId: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      receive_nft: {
        msg,
        sender,
        token_id: tokenId
      }
    }, fee, memo, _funds);
  };
  cancelAuction = async ({
    auctionId
  }: {
    auctionId: Uint128;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      cancel_auction: {
        auction_id: auctionId
      }
    }, fee, memo, _funds);
  };
  placeBid = async ({
    auctionId
  }: {
    auctionId: Uint128;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      place_bid: {
        auction_id: auctionId
      }
    }, fee, memo, _funds);
  };
  settle = async ({
    auctionId
  }: {
    auctionId: Uint128;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      settle: {
        auction_id: auctionId
      }
    }, fee, memo, _funds);
  };
  adminChangeConfig = async ({
    acceptedDenom,
    collectorAddress,
    duration,
    extensionDuration,
    maxRoyaltyFee,
    minIncrement,
    minReservePrice,
    protocolFee
  }: {
    acceptedDenom: string[];
    collectorAddress: string;
    duration: number;
    extensionDuration: number;
    maxRoyaltyFee: Decimal;
    minIncrement: Decimal;
    minReservePrice: Uint128;
    protocolFee: Decimal;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      admin_change_config: {
        accepted_denom: acceptedDenom,
        collector_address: collectorAddress,
        duration,
        extension_duration: extensionDuration,
        max_royalty_fee: maxRoyaltyFee,
        min_increment: minIncrement,
        min_reserve_price: minReservePrice,
        protocol_fee: protocolFee
      }
    }, fee, memo, _funds);
  };
  adminCancelAuction = async ({
    auctionId
  }: {
    auctionId: Uint128;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      admin_cancel_auction: {
        auction_id: auctionId
      }
    }, fee, memo, _funds);
  };
  setRoyaltyFee = async ({
    contractAddr,
    creator,
    royaltyFee
  }: {
    contractAddr: string;
    creator: string;
    royaltyFee: Decimal;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      set_royalty_fee: {
        contract_addr: contractAddr,
        creator,
        royalty_fee: royaltyFee
      }
    }, fee, memo, _funds);
  };
  setRoyaltyAdmin = async ({
    address,
    enable
  }: {
    address: string;
    enable: boolean;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      set_royalty_admin: {
        address,
        enable
      }
    }, fee, memo, _funds);
  };
  adminPause = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      admin_pause: {}
    }, fee, memo, _funds);
  };
  adminResume = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      admin_resume: {}
    }, fee, memo, _funds);
  };
  settleHook = async ({
    nftContract,
    owner,
    tokenId
  }: {
    nftContract: string;
    owner: string;
    tokenId: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      settle_hook: {
        nft_contract: nftContract,
        owner,
        token_id: tokenId
      }
    }, fee, memo, _funds);
  };
}